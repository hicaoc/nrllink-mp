// audioPlayer.js
const webAudioContext = wx.createWebAudioContext();

// 音频流相关参数
const SAMPLE_RATE = 8000;
const BUFFER_SIZE = 1024; // 建议选择较小的值，以降低延迟

// WebAudio 资源
const audioContext = webAudioContext;
const gainNode = audioContext.createGain();
gainNode.connect(audioContext.destination);
//gainNode.gain.value = 1.0;

let scriptProcessorNode = null;

// G.711 编解码器
import * as g711 from './audioG711';
const g711Codec = new g711.G711Codec();

// 用于存储未播放的 PCM 数据
let pcmBuffer = new Float32Array(0);

// 初始化 WebAudio
function initWebAudio() {
    scriptProcessorNode = audioContext.createScriptProcessor(BUFFER_SIZE, 1, 1);

    scriptProcessorNode.onaudioprocess = (audioProcessingEvent) => {
        const outputBuffer = audioProcessingEvent.outputBuffer;
        const outputData = outputBuffer.getChannelData(0);

        // 如果有足够的 PCM 数据，则填充输出缓冲区
        if (pcmBuffer.length >= BUFFER_SIZE) {
            for (let i = 0; i < BUFFER_SIZE; i++) {
                outputData[i] = pcmBuffer[i];
            }

            // 从 pcmBuffer 中移除已播放的数据
            pcmBuffer = pcmBuffer.slice(BUFFER_SIZE);
        } else {
            // 如果 PCM 数据不足，则填充静音
            for (let i = 0; i < BUFFER_SIZE; i++) {
                outputData[i] = 0;
            }
        }

        // 调试：打印输出缓冲区的一些值
        //console.log("outputData[0]:", outputData[0], "outputData[1]:", outputData[1]);
    };

    scriptProcessorNode.connect(gainNode);

     // 调试： 打印 audioContext 的采样率
     console.log("audioContext.sampleRate:", audioContext.sampleRate);
     console.log("SAMPLE_RATE:", SAMPLE_RATE);

}

// 接收 G.711 数据并解码
async function play(data, type) {
    if (type === 1) {
        const pcmData = new Int16Array(data.length);
        for (let i = 0; i < data.length; i++) {
            pcmData[i] = g711Codec.alaw2linear(data[i]);
        }

        const float32Data = new Float32Array(pcmData.length);
        for (let i = 0; i < pcmData.length; i++) {
            float32Data[i] = Math.max(-1, Math.min(1, pcmData[i] / 32768.0));
        }

        // 采样率转换
        const resampledData = resamplePCM(float32Data, SAMPLE_RATE, audioContext.sampleRate);

        // 合并 PCM 数据
        const newPcmBuffer = new Float32Array(pcmBuffer.length + resampledData.length);
        newPcmBuffer.set(pcmBuffer, 0);
        newPcmBuffer.set(resampledData, pcmBuffer.length);
        pcmBuffer = newPcmBuffer;
    }
}

function resamplePCM(input, inputSampleRate, outputSampleRate) {
    const ratio = outputSampleRate / inputSampleRate;
    const outputLength = Math.round(input.length * ratio);
    const output = new Float32Array(outputLength);

    for (let i = 0; i < outputLength; i++) {
        const originalIndex = i / ratio;
        const lowerIndex = Math.floor(originalIndex);
        const upperIndex = Math.min(Math.ceil(originalIndex), input.length - 1);
        const weight = originalIndex - lowerIndex;

        output[i] = input[lowerIndex] * (1 - weight) + input[upperIndex] * weight;
    }

    return output;
}

module.exports = {
    initWebAudio,
    play,
};